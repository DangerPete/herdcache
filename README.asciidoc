= HerdCache

A Cache using futures to defend against thundering herds.

The cache borrows heavily from the concepts, and implementation 
of caching in http://spray.io/documentation/1.2.1/spray-caching/[spray-caching]

The idea here being that the cache stores a future rather than the value, rather than
values of a given generic type.  The benefit of this approach is that is that is has the advantage, that it
nicely takes care of thundering herds/cache miss storm issue.  Which is where many requests
to a particular cache key (e.g. a resource URI) arrive before the first one could be completed. The result
being that the cache key is requested ( the processing associated with calculating the value is performed ) multiple
times.  As a result the backend resource is put under undue load.

Storing a future in the cache means that multiple resources for a missing cache value that hasn't been calculated,
wait on the same future that is executing for the initial/first request for the cache key.

== Cache Types

There are currently two types of Cache that implement the `Cache<V>`:

- `SimpleLastRecentlyUsedCache`
- `ExpiringLastRecentlyUsedCache`


The cache has a single method `apply` that takes:

- The key to look for
- An implementation of the http://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html[`Supplier<T>`] functional interface
- The guava http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/ListeningExecutorService.html[`ListeningExecutorService`] executor


=== SimpleLastRecentlyUsedCache

This cache uses a https://code.google.com/p/concurrentlinkedhashmap/[ConcurrentLinkedHashMap] to store a maximum number
of values in the cache.  Once the cache hit the maximum number of values, the key that has been Last recently used is
removed

==== Examples

[source,java]
----
ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));
Cache<String> cache = new SimpleLastRecentlyUsedCache<>();

ListenableFuture<String> val = cache.apply("Key1",
                                           () -> {
                                                try {
                                                    Thread.sleep(1000);
                                                } catch (InterruptedException e) {
                                                    e.printStackTrace();
                                                }
                                                return "key1";
                                           },
                                           executorService);
----


The `SimpleLastRecentlyUsedCache` has no expiry on the items in the cache.  It is just limited by the number of
items in the cache and the item that has been last recently used.

This can be seen in the following example:

[source,java]
----
ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));
Cache<String> cache = new SimpleLastRecentlyUsedCache<>();

ListenableFuture<String> val = cache.apply("Key1", () -> {
  try {
     Thread.sleep(1000);
  } catch (InterruptedException e) {
     e.printStackTrace();
  }
  return "key1";
}, executorService);


ListenableFuture<String> val2 = cache.apply("key2", () -> {
  try {
     Thread.sleep(500);
  } catch (InterruptedException e) {
     e.printStackTrace();
  }
  return "key2";
}, executorService);


ListenableFuture<String> val3 = cache.apply("key3", () -> {
  try {
     Thread.sleep(500);
  } catch (InterruptedException e) {
     e.printStackTrace();
  }
  return "key3";
}, executorService);

ListenableFuture<String> val4 = cache.apply("key1", () -> {
  try {
    Thread.sleep(500);
  } catch (InterruptedException e) {
    e.printStackTrace();
  }
  return "key_new";
}, executorService);


assertEquals("Value should be key1","key1",this.awaitForFutureOrElse(val, null));
assertEquals("Value should be key2","key2",this.awaitForFutureOrElse(val2, null));
assertEquals("Value should be key3","key3",this.awaitForFutureOrElse(val3, null));

// Key1 will no longer be in the cache, only key2 and key3
assertEquals("Value should be key1","key_new",this.awaitForFutureOrElse(val4, null));

----

=== ExpiringLastRecentlyUsedCache

The difference between `SimpleLastRecentlyUsedCache` and `ExpiringLastRecentlyUsedCache` is that the later has a default
time to live for the elements that are put in the cache, and also; if desired, a time to idle for the items.

The `timeToLive` and `timeToIdle` are supplied to the constructor of the cache:

===== Using Only Time to Live

Example, of creating a cache for which the item will live for 1 minute, regardless of when they were last used:

[source,java]
----
new ExpiringLastRecentlyUsedCache<>(10,60,0, TimeUnit.SECONDS));
----


===== Using Time to Live, and Time to Idle

Example, of creating a cache for which the item will live for 1 minute, but have to be used within the last 30 SECONDS

[source,java]
----
new ExpiringLastRecentlyUsedCache<>(10,60,30, TimeUnit.SECONDS));
----



=== Waiting on futures

