

= HerdCache

:toc:
:toclevels: 4
:toc-title: A Cache using futures to defend against thundering herds.
:toc-placement!:

toc::[]


= Overview

The cache borrows heavily from the concepts, and implementation 
of caching in http://spray.io/documentation/1.2.1/spray-caching/[spray-caching]

The idea here being that the cache stores a future rather than the value, rather than
values of a given generic type.  The benefit of this approach is that is that is has the advantage, that it
nicely takes care of thundering herds/cache miss storm issue.  Which is where many requests
to a particular cache key (e.g. a resource URI) arrive before the first one could be completed. The result
being that the cache key is requested ( the processing associated with calculating the value is performed ) multiple
times.  As a result the backend resource is put under undue load.

Storing a future in the cache means that multiple resources for a missing cache value that hasn't been calculated,
wait on the same future that is executing for the initial/first request for the cache key.

'''

= Usage

The below details how to use the caching implementations, the differences between them.


== Dependency

[source,xml]
----
<dependency>
  <groupId>org.greencheek.caching</groupId>
  <artifactId>herdcache</artifactId>
  <version>0.1.0</version>
</dependency>
----

== Cache Types

There are currently two types of Cache that implement the `Cache<V>`:

- `SimpleLastRecentlyUsedCache`
- `ExpiringLastRecentlyUsedCache`


The cache has a single method `apply` that takes:

- The key to look for
- An implementation of the http://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html[`Supplier<T>`] functional interface
- The guava http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/ListeningExecutorService.html[`ListeningExecutorService`] executor

The method is: `ListenableFuture<V> apply(String key, Supplier<V> computation, ListeningExecutorService executorService)`


The returned value is that of http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/util/concurrent/ListenableFuture.html[Guava's ListenableFuture],
upon which you can attach a callback, or wait for a value to be generated:


- Adding a callback:
[source,java]
-----
// Executes on the calling thread
Futures.addCallback(future,new FutureCallback<String>() {
                        @Override
                        public void onSuccess(String result) {

                        }

                        @Override
                        public void onFailure(Throwable t) {

                        }
                   });


// Executes on the passing in executor thread pool
private final ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));

Futures.addCallback(val,new FutureCallback<String>() {
            @Override
            public void onSuccess(String result) {

            }

            @Override
            public void onFailure(Throwable t) {

            }
},executorService);
----

- Waiting for the value (or failure)
[source,java]
----
        try {
            future.get();
        } catch (InterruptedException e) {

        } catch (ExecutionException e) {

        }
----

'''

=== SimpleLastRecentlyUsedCache

This cache uses a https://code.google.com/p/concurrentlinkedhashmap/[ConcurrentLinkedHashMap] to store a maximum number
of values in the cache.  Once the cache hit the maximum number of values, the key that has been Last recently used is
removed

'''

==== Examples

[source,java]
----
ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));
Cache<String> cache = new SimpleLastRecentlyUsedCache<>();

ListenableFuture<String> val = cache.apply("Key1",
                                           () -> {
                                                try {
                                                    Thread.sleep(1000);
                                                } catch (InterruptedException e) {
                                                    e.printStackTrace();
                                                }
                                                return "key1";
                                           },
                                           executorService);
----


The `SimpleLastRecentlyUsedCache` has no expiry on the items in the cache.  It is just limited by the number of
items in the cache and the item that has been last recently used.

This can be seen in the following example:

[source,java]
----
ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));
Cache<String> cache = new SimpleLastRecentlyUsedCache<>();

ListenableFuture<String> val = cache.apply("Key1", () -> {
  try {
     Thread.sleep(1000);
  } catch (InterruptedException e) {
     e.printStackTrace();
  }
  return "key1";
}, executorService);


ListenableFuture<String> val2 = cache.apply("key2", () -> {
  try {
     Thread.sleep(500);
  } catch (InterruptedException e) {
     e.printStackTrace();
  }
  return "key2";
}, executorService);


ListenableFuture<String> val3 = cache.apply("key3", () -> {
  try {
     Thread.sleep(500);
  } catch (InterruptedException e) {
     e.printStackTrace();
  }
  return "key3";
}, executorService);

ListenableFuture<String> val4 = cache.apply("key1", () -> {
  try {
    Thread.sleep(500);
  } catch (InterruptedException e) {
    e.printStackTrace();
  }
  return "key_new";
}, executorService);


assertEquals("Value should be key1","key1",this.awaitForFutureOrElse(val, null));
assertEquals("Value should be key2","key2",this.awaitForFutureOrElse(val2, null));
assertEquals("Value should be key3","key3",this.awaitForFutureOrElse(val3, null));

// Key1 will no longer be in the cache, only key2 and key3
assertEquals("Value should be key1","key_new",this.awaitForFutureOrElse(val4, null));

----

'''

=== ExpiringLastRecentlyUsedCache

The difference between `SimpleLastRecentlyUsedCache` and `ExpiringLastRecentlyUsedCache` is that the later has a default
time to live for the elements that are put in the cache, and also; if desired, a time to idle for the items.

The `timeToLive` and `timeToIdle` are supplied to the constructor of the cache:

'''

===== Using Only Time to Live

Example, of creating a cache for which the item will live for 1 minute, regardless of when they were last used:

[source,java]
----
new ExpiringLastRecentlyUsedCache<>(10,60,0, TimeUnit.SECONDS));
----

'''

===== Using Time to Live, and Time to Idle

Example, of creating a cache for which the item will live for 1 minute, but have to be used within the last 30 SECONDS

[source,java]
----
new ExpiringLastRecentlyUsedCache<>(10,60,30, TimeUnit.SECONDS));
----

'''

=== Waiting on futures

The `Cache<V>` interface inherits a Utility interface that gives you a couple of utility methods that allow you to wait
on futures, for a value to be calculated

- `V awaitForFutureOrElse(ListenableFuture<V> future, V onExceptionValue)`
- `V awaitForFutureOrElse(ListenableFuture<V> future, V onExceptionValue, V onTimeoutValue, long duration, TimeUnit timeUnit)`


==== Wait on future, with fallback value incase of exception

A the value returned back from a cache apply is that of a `ListenableFuture`.  You can naturally wait on the currently
executing thread (blocking that thread), for a value to be returned.  This is as follows:

[source,java]
----
try {
   return future.get();
} catch (Exception e) {
   return somefallback;
}
----

The method `V awaitForFutureOrElse(ListenableFuture<V> future, V onExceptionValue)`, remove the ceremony of the try/catch
block for you.


The other method `V awaitForFutureOrElse(ListenableFuture<V> future, V onExceptionValue, V onTimeoutValue, long duration, TimeUnit timeUnit)`
allows you wait a finite amount of time for a value to be returned.  The amount of time elapsed, the `onTimeoutValue` is going to be returned.
Any other exception results in the `onExceptionValue` being thrown.